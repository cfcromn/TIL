# JWT란?

JWT는 JSON Web Token의 약자로, 클라이언트와 서버 간에 보안 정보를 공유하는 데 사용되는 개방형 표준이다. 인증된 사용자에게 서버가 토큰을 발급하고, 클라이언트는 이후 요청마다 이 토큰을 전송하여 인증을 대신한다.

과거에는 사용자 인증 정보를 유지하기 위해 서버가 세션 정보를 저장하는 방식이 일반적이었지만, 서버에 상태를 저장해야 한다는 단점이 있었다. JWT는 이러한 문제를 해결하기 위해 등장한 무상태(Stateless) 인증 방식으로, 서버에 인증 상태를 저장하지 않고도 인증을 유지할 수 있다는 장점이 있다.

# JSON이란?

그럼 JSON이 뭔지 알아보자

JSON은 JavaScript Object Notation의 약자로 데이터를 쉽게 교환하고 저장하기 위한 텍스트 기반의 데이터 교환 표준이다.

# 토큰이란?

사용자가 로그인하면, 서버가 사용자임을 확인한 뒤 **토큰**이라는 인증 정보를 발급해준다. 이 토큰은 이후의 요청에서 로그인을 증명하는 역할을 한다.

# JWT 구조

JWT는 .(닷)으로 구분된 3개의 문자열로 구성된다.

```
xxxxx.yyyyy.zzzzz
```

이 세 부분은 각각 **Base64Url 방식으로 인코딩**된 텍스트이며, 쉽게 디코딩하여 내용을 확인할 수 있다. 각 부분은 다음과 같다:

- **Header(헤더)** : 토큰의 타입(JWT)과 서명에 사용할 알고리즘 명시
- **Payload(페이로드)** : 사용자 정보 및 기타 클레임 담음
- **Signature(서명)** : 위의 두 부분을 비밀 키를 사용해 서명한 값으로, 토큰이 위조되지 않았는지 확인할 수 있도록 도와준다

서명(Signature)은 다음과 같이 생성된다:

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

이 서명 덕분에 JWT는 **위조 방지** 기능을 가지며, 서버는 전달받은 토큰이 변조되지 않았는지 확인할 수 있다.

ex)

**Header**

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Payload**

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "role": "admin",
  "exp": 1712345678
}
```

# JWT의 동작 흐름

1. 로그인 요청
    - 사용자가 아이디/비밀번호로 로그인
2. 서버에서 JWT 생성 및 반환
    - 인증에 성공하면 서버가 JWT를 생성하여 클라이언트에게 반환
3. 클라이언트에서 JWT 저장
    - 클라이언트(브라우저)는 JWT를 localStorage나  cookie 등을 저장
4. 요청 시 JWT 전송
    - 이후 요청마다 HTTP Header에 JWT 포함 (`Authorization: Bearer <JWT>`)
5. 서버에서 토큰 검증 후 응답
    - 서버는 서명 검증 및 exp 등을 검사 후 요청 처리

# JWT의 장단점

### 장점

- 무상태(Stateless) : 서버에 세션을 저장하지 않음 - 수평 확장에 유리
- 간편한 인증 전달 : HTTP Header을 포함시켜 간편하게 인증 정보 전달
- 다양한 플랫폼에 사용 가능 : RESTful API, SPA, 모바일 앱 등에 적합

### 단점

- 토큰 폐기 어려움 : 발급 후 바로 폐기 불가능
- 토큰 크기 큼 : 모든 정보가 포함되므로 일반 세션 ID보다 크다.
- 보안 주의 필요 : 토큰 탈취 시 위험 → HTTPS 사용 필수

## Access Token과 Refresh Token

JWT는 발급 후 중간에 폐기하거나 무효화하기 어렵다는 단점이 있다. 이를 보완하기 위해 실무에서는 **Access Token**과 **Refresh Token**을 함께 사용하는 방식을 많이 사용한다.

- **Access Token**: 짧은 유효 기간을 가진 토큰으로, 일반적인 API 요청에 사용된다.
- **Refresh Token**: Access Token이 만료되었을 때 새로운 Access Token을 발급받기 위한 용도로 사용되며, 보통 서버에 저장하거나 DB에 보관된다.

이러한 구조를 사용하면 보안성이 높아지며, 토큰 탈취나 만료에 유연하게 대응할 수 있다.

> 예를 들어, Access Token은 15분짜리 짧은 토큰으로 설정하고, Refresh Token은 2주 이상으로 설정하여 로그인 유지 기능을 구현할 수 있다.
> 

# 주요 클레임(Claims)

| Claim | 설명 |
| --- | --- |
| `iss` | 발급자 (issuer) |
| `sub` | 사용자 식별자 (subject) |
| `exp` | 만료 시간 (expiration) |
| `iat` | 발급 시간 (issued at) |
| `aud` | 대상자 (audience) |
| `nbf` | Not Before – 이 시간 이전에는 무효 |

## 클레임(Claims)은 또 뭘까?

JWT에서 클레임은 토큰에 담기는 정보다.

쉽게 말하자면 토큰에 들어가는 데이터 조각이라고 할 수 있다. 클레임을 통해 사용자 정보나 권한 같은 내용을 담을 수 있고, 서버나 클라이언트가 이를 읽고 판단한다.

클레임은 크게 다음 세 가지로 나뉜다:

- **등록된 클레임(Registered Claims)**
    
    JWT 표준에서 미리 정의해놓은 클레임들로, `iss`, `sub`, `exp`, `iat`, `aud`, `nbf` 등이 있다.
    
- **공개 클레임(Public Claims)**
    
    누구나 사용할 수 있는 클레임이지만, **충돌 방지를 위해 URI 형식으로 네임스페이스를 지정**하는 것이 좋다. 예: `"<https://example.com/user_id>"`.
    
- **비공개 클레임(Private Claims)**
    
    발급자와 수신자 간에 자유롭게 정의하는 클레임으로, 예: `role`, `userId`, `isPremium` 등. 시스템 내부에서만 의미가 있고, 외부 표준과는 관계 없다.
    

> 실무에서는 Registered + Private 조합을 가장 많이 사용하며, 민감한 정보는 클레임에 절대 포함하지 않는 것이 보안상 중요하다.
> 

# 마무리

JWT는 간편하고 확장성 좋은 인증 방식이지만, 보안에 대한 고려가 반드시 필요하다.

Access/Refresh Token 전략을 함께 사용하고, 토큰 저장 위치와 만료 시간을 신중히 설정하면 보다 안전하게 활용할 수 있다.